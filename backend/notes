Choose storage
Local folder (uploads/avatars) or cloud (S3/Cloudinary). Add env config.


Install backend deps
multer (or busboy) for uploads; sharp (optional) for resize/convert.


Backend middleware
Configure Multer: single file field avatar, size limit (e.g., 2MB), mime allowlist (image/jpeg,png,webp).
Optional: process with sharp (max 512x512, convert to webp/jpg).


Serve/prepare storage
Local: ensure folder exists; serve static: app.use('/uploads', express.static('uploads')).
Cloud: set SDK, bucket/cloud name, credentials.


Backend route/controller
Add PUT /api/profile/avatar (auth-protected) to accept multipart/form-data.
Save file (local path or cloud URL), update user.avatar, delete old image if replacing.
Return updated profile JSON.


Security/hygiene
Validate size/type server-side.
Generate unique filenames; never trust original names.
Sanitize paths; handle errors consistently.


Frontend API util
Create uploadAvatar(file):
Build FormData; formData.append('avatar', file).
Call apiFetch('/profile/avatar', { method: 'PUT', body: formData }) without setting Content-Type.


Auth context integration
Expose uploadAvatar in AuthContext.
On success, update profile.avatar and optionally add cache-buster (?v=${Date.now()}).


UI changes
In ProfileEditModal or a dedicated avatar section, add:
<input type="file" accept="image/*">, preview, and “Upload photo” button.
Disable controls during upload; show spinner.


Client validation
Check file type/size before upload; show inline errors.


Feedback UX
Success/error messages (toast or alert).
Optional upload progress (use axios or XHR for progress events).
Display avatar
Update header/profile card to show the uploaded image; fallback to initials if missing.


Optional enhancements
Add cropper before upload (e.g., react-easy-crop).
Generate multiple sizes on server.
Tests: valid/invalid type, oversize, replace existing, unauthorized.

done step 1